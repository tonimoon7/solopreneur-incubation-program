# Block 4: session-analyzer로 스킬 실행 검증

> 공식 문서: https://code.claude.com/docs/ko/skills
> 참고: https://code.claude.com/docs/ko/sub-agents

## EXPLAIN

### 왜 검증이 필요한가?

Block 1에서 만든 session-wrap 스킬이 "진짜로" 의도대로 동작했는지 확인해야 합니다.

비유하면 이렇습니다. 요리를 만들었으면 레시피대로 만들었는지 확인해야 합니다. 소금을 넣으라고 했는데 설탕을 넣었을 수도 있고, 3분 끓이라고 했는데 10분 끓였을 수도 있습니다. **스킬을 만드는 것과 스킬이 올바르게 동작하는 것은 다른 문제입니다.**

SKILL.md에 "이렇게 해라"라고 써놨다고 해서 Claude가 100% 그대로 실행한다는 보장이 없습니다. 그래서 검증이 필요합니다.

### session-analyzer가 하는 일

session-analyzer는 **SKILL.md(설계도)와 실제 실행 기록을 비교**하는 도구입니다. 비유하면 "감독관"입니다. 설계도를 들고 현장에 나가서, 실제로 설계도대로 지어졌는지 하나하나 체크합니다.

6단계로 분석합니다:

| 단계 | 하는 일 | 비유 |
|------|---------|------|
| 1. 세션 파일 찾기 | 로그 파일 위치 파악 | CCTV 녹화본 찾기 |
| 2. SKILL.md 파싱 | 기대 동작 추출 | 설계도 읽기 |
| 3. 세션 기록 분석 | 실제 동작 추출 | CCTV 녹화본 재생 |
| 4. 아티팩트 검증 | 파일 생성/삭제 확인 | 결과물 현장 확인 |
| 5. Expected vs Actual 비교 | 표로 정리 | 설계도 vs 현장 대조표 작성 |
| 6. 리포트 생성 | PASS/FAIL 판정 | 합격/불합격 판정 |

### 비교 테이블 예시

실제로 session-analyzer가 만들어주는 결과는 이런 형태입니다:

| 구성요소 | 기대한 것 | 실제 결과 | 판정 |
|----------|-----------|-----------|------|
| doc-updater | 병렬 실행 | 09:39에 실행 | PASS |
| duplicate-chk | Phase 1 후 실행 | Phase 1 후 실행 | PASS |
| 결과 파일 | 생성됨 | 존재 확인 | PASS |
| 요약 포맷 | Markdown 표 | 일반 텍스트 | FAIL |

PASS는 설계도대로 된 것, FAIL은 설계도와 다른 것입니다.

### 이게 왜 중요한가?

- 스킬을 만들면 **테스트가 필수**입니다. 한 번에 완벽한 스킬은 없습니다.
- session-analyzer는 이 테스트를 **자동화**해주는 도구입니다.
- 사람이 눈으로 로그를 일일이 읽는 대신, AI가 설계도와 대조해서 문제를 찾아줍니다.
- "코드 리뷰"를 AI가 대신 해주는 것이라고 생각하면 됩니다.

## EXECUTE

### 사전 확인

session-analyzer 스킬이 설치되어 있는지 확인합니다. Claude Code에서:

```
어떤 스킬이 설치되어 있어?
```

목록에 `session-analyzer`가 있으면 아래 단계로 진행합니다. 없다면 강사에게 문의하세요.

### 1단계: session-analyzer 실행

Block 2에서 사용했던 작업 세션 탭이 아직 열려 있으면 그 탭에서, 닫았다면 새 터미널 탭(`Cmd + T`)을 열고 같은 프로젝트 폴더로 이동한 뒤 `claude`를 실행합니다.

아래 명령으로 분석을 시작합니다:

```
/session-analyzer
```

또는 자연어로:

```
가장 최근에 /my-session-wrap을 실행한 세션을 분석해줘
```

> 슬래시 명령어(`/session-analyzer`)와 자연어, 둘 다 같은 결과를 냅니다. 편한 방식을 쓰면 됩니다.

> Claude가 자동으로 해당 세션을 찾아서 분석합니다. 세션 ID 같은 것을 직접 찾을 필요는 없습니다.

> **세션을 못 찾는 경우**: "세션을 찾을 수 없다"고 나오면, "현재 프로젝트의 가장 최근 세션을 분석해줘"라고 범위를 넓혀보세요.

### 2단계: 분석 결과 확인

6단계 리포트가 나오면 아래를 확인합니다:

- Expected vs Actual 비교 테이블에서 **FAIL 항목이 있는지**
- FAIL이 있다면 **어떤 부분이 문제인지** 구체적으로 확인
- 전체 판정이 PASS인지 FAIL인지

### 3단계: 문제 발견 시 수정

만약 FAIL이 있다면, Claude에게 바로 수정을 요청합니다:

```
이 FAIL 항목을 수정할 수 있도록 my-session-wrap SKILL.md를 고쳐줘
```

> 직접 Block 1로 돌아갈 필요 없이, Claude가 FAIL 내용을 보고 즉시 수정해줍니다. 수정 후 다시 `/session-analyzer`로 확인하면 됩니다.

> 모든 항목이 PASS가 아니어도 괜찮습니다. 핵심 기능(에이전트 병렬 실행, 결과 출력)이 동작하면 성공입니다.

> **Block 2에서 session-wrap을 실행하지 못한 경우**: "원본 session-wrap 플러그인의 가장 최근 실행 세션을 분석해줘"라고 요청하세요. 직접 만든 스킬 대신 원본 플러그인의 실행 기록으로 session-analyzer를 체험할 수 있습니다.

### 4단계: Day 4 종합 정리

모든 검증이 끝났다면, 오늘 배운 것을 정리합니다. Claude Code에 아래와 같이 입력하세요:

```
오늘 Day 4에서 배운 것을 정리해줘:
1. session-wrap 스킬 구조
2. 직접 만들어본 경험
3. history-insight로 분석한 것
4. session-analyzer로 검증한 것
```

> Claude가 오늘 과정 전체를 요약해줍니다. 이 요약을 나중에 다시 보면 복습이 됩니다.

## QUIZ

> Block 4는 Day 4의 마지막 블록입니다. 종합 퀴즈로 오늘 배운 것을 정리합니다.

### Quiz 4: Day 4 종합

```json
AskUserQuestion({
  "questions": [{
    "question": "Day 4 종합: 스킬을 만들고 -> 실행하고 -> 검증하는 전체 과정에서, 가장 중요한 원칙은?",
    "header": "Quiz 4",
    "options": [
      {"label": "만들기 -> 실행 -> 검증의 반복 (iteration)", "description": "한 번에 완벽할 수 없으므로 반복하면서 개선"},
      {"label": "처음부터 완벽한 SKILL.md 작성", "description": "설계가 완벽하면 검증이 불필요"},
      {"label": "가능한 많은 에이전트 사용", "description": "에이전트가 많을수록 좋은 결과"}
    ],
    "multiSelect": false
  }]
})
```

정답: 만들기 -> 실행 -> 검증의 반복 (iteration)
피드백: "정확합니다! 스킬 개발은 한 번에 완벽할 수 없습니다. **만들기(Block 1) -> 실행(Block 2) -> 검증(Block 4)의 반복**이 핵심입니다. session-analyzer가 이 검증을 자동화해주므로, 빠르게 문제를 발견하고 수정할 수 있습니다. 이 'iteration' 사이클이 AI 네이티브 업무 방식의 핵심입니다."

---

## 마무리

여기까지 오신 것을 축하합니다! 오늘 여러분은 AI에게 "일을 시키는 구조"를 직접 설계하고 실행해봤습니다.

Day 4를 통해 배운 3가지 핵심:

1. **Multi-agent 패턴**: 여러 전문가에게 동시에 일을 시키고, 결과를 검증하는 구조
2. **스킬 만들기**: SKILL.md 하나로 나만의 자동화 워크플로우 구축
3. **검증 루프**: 만들고 -> 실행하고 -> 분석하는 반복이 품질을 만든다

> 다음 Day에서는 이 패턴을 더 확장하여 자신만의 워크플로우를 구축합니다.
